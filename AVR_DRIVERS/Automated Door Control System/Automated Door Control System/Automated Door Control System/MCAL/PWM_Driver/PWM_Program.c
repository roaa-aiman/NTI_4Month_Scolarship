/*
 * PWM_Program.c
 *
 * Created: 3/17/2024 10:46:04 AM
 *  Author: Roaa Aiman
 */ 
#include "STD_TYPES.h"
#include "BIT_MATH.h"

#include "DIO_interface.h"

#include "PWM_Interface.h"
#include "PWM_Private.h"
#include "PWM_Register.h"
#include "PWM_Config.h"

void PWM_voidInitializeChannel_0(void)
{
	
	#if TIMER0_MODE == TIMER0_PWM_MODE
	SET_BIT(TCCR0_REG, TCCR0_WGM00);
	CLR_BIT(TCCR0_REG, TCCR0_WGM01);
	#elif TIMER0_MODE == TIMER0_FAST_PWM_MODE
	SET_BIT(TCCR0_REG, TCCR0_WGM00);
	SET_BIT(TCCR0_REG, TCCR0_WGM01);
	#else
	//error
	#endif
	
	
    /*Set Fast PWM Mode*/
	#if TIMER0_FAST_PWM_MODE_SELECT == TIMER0_NORMAL_MODE_FAST_PWM
	CLR_BIT(TCCR0_REG, TCCR0_COM00);
	CLR_BIT(TCCR0_REG, TCCR0_COM01);
	#elif TIMER0_FAST_PWM_MODE_SELECT == TIMER0_CLEAR_ON_COMPARE_FAST_PWM
	CLR_BIT(TCCR0_REG, TCCR0_COM00);
	SET_BIT(TCCR0_REG, TCCR0_COM01);
	#elif TIMER0_FAST_PWM_MODE_SELECT == TIMER0_SET_ON_COMPARE_FAST_PWM
	SET_BIT(TCCR0_REG, TCCR0_COM00);
	SET_BIT(TCCR0_REG, TCCR0_COM01);
	#else
	//error
	#endif
}

void PWM_voidStopChannel_0(void)
{
	CLR_BIT(TCCR0_REG, TCCR0_CS00);
	CLR_BIT(TCCR0_REG, TCCR0_CS01);
	CLR_BIT(TCCR0_REG, TCCR0_CS02);
}
void PWM_voidGenerateChannel_0 (u8 copy_u8DutyCycle)
{
	if (copy_u8DutyCycle<=100)
	{
		OCR0_REG = (((u16)copy_u8DutyCycle*256)/100)-1;
		/*Select Clock Prescaler*/
		#if TIMER0_SELECT_CLK == TIMER0_NO_CLK
		CLR_BIT(TCCR0_REG, TCCR0_CS00);
		CLR_BIT(TCCR0_REG, TCCR0_CS01);
		CLR_BIT(TCCR0_REG, TCCR0_CS02);

		#elif TIMER0_SELECT_CLK == TIMER0_CLK_NO_PRESCALER
		SET_BIT(TCCR0_REG, TCCR0_CS00);
		CLR_BIT(TCCR0_REG, TCCR0_CS01);
		CLR_BIT(TCCR0_REG, TCCR0_CS02);

		#elif TIMER0_SELECT_CLK == TIMER0_CLK_DIVIDED_BY_8
		CLR_BIT(TCCR0_REG, TCCR0_CS00);
		SET_BIT(TCCR0_REG, TCCR0_CS01);
		CLR_BIT(TCCR0_REG, TCCR0_CS02);

		#elif TIMER0_SELECT_CLK == TIMER0_CLK_DIVIDED_BY_64
		SET_BIT(TCCR0_REG, TCCR0_CS00);
		SET_BIT(TCCR0_REG, TCCR0_CS01);
		CLR_BIT(TCCR0_REG, TCCR0_CS02);


		#elif TIMER0_SELECT_CLK == TIMER0_CLK_DIVIDED_BY_256
		CLR_BIT(TCCR0_REG, TCCR0_CS00);
		CLR_BIT(TCCR0_REG, TCCR0_CS01);
		SET_BIT(TCCR0_REG, TCCR0_CS02);

		#elif TIMER0_SELECT_CLK == TIMER0_CLK_DIVIDED_BY_1024
		SET_BIT(TCCR0_REG, TCCR0_CS00);
		CLR_BIT(TCCR0_REG, TCCR0_CS01);
		SET_BIT(TCCR0_REG, TCCR0_CS02);

		#elif TIMER0_SELECT_CLK == TIMER0_CLK_ON_FALLING_EDGE
		CLR_BIT(TCCR0_REG, TCCR0_CS00);
		SET_BIT(TCCR0_REG, TCCR0_CS01);
		SET_BIT(TCCR0_REG, TCCR0_CS02);

		#elif TIMER0_SELECT_CLK == TIMER0_CLK_ON_RISING_EDGE
		SET_BIT(TCCR0_REG, TCCR0_CS00);
		SET_BIT(TCCR0_REG, TCCR0_CS01);
		SET_BIT(TCCR0_REG, TCCR0_CS02);
		#else
		//error
		#endif
		
		
	}
	else
	{
		//return error state
	}

}

void PWM_voidInitializeChannel_1A(void)
{
	
	CLR_BIT(TCCR1A_REG, TCCR1A_WGM10);
	SET_BIT(TCCR1A_REG, TCCR1A_WGM11);
	SET_BIT(TCCR1B_REG, TCCR1B_WGM12);
	SET_BIT(TCCR1B_REG, TCCR1B_WGM13);
	
	CLR_BIT(TCCR1A_REG, TCCR1A_COM1A0);
	SET_BIT(TCCR1A_REG, TCCR1A_COM1A1);
	
}

void PWM_voidStopChannel_1A(void)
{
	CLR_BIT(TCCR1B_REG, TCCR1B_CS10);
	CLR_BIT(TCCR1B_REG, TCCR1B_CS11);
	CLR_BIT(TCCR1B_REG, TCCR1B_CS12);
}
void PWM_voidGenerateChannel_1A (u32 copy_u32Frequency_HZ,f32 copy_f32DutyCycle)
{
	if(copy_f32DutyCycle<=100)
	{
		ICR1L_REG = (((u32)1000000/copy_u32Frequency_HZ)/4)-1;
		OCR1AL_REG = ((copy_f32DutyCycle*(ICR1L_REG+1))/100)-1;
		
		SET_BIT(TCCR1B_REG, TCCR1B_CS10);
		SET_BIT(TCCR1B_REG, TCCR1B_CS11);
		CLR_BIT(TCCR1B_REG, TCCR1B_CS12);
		
	}
	else
	{
		//error
	}
}