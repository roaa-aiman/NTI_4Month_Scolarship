/*
 * ADC_program.c
 *
 * Created: 3/4/2024 11:31:18 AM
 *  Author: Roaa aiman 
 */
#include "ADC_interface.h" 
void ADC_voidInit(u8 copy_u8ReferrenceVoltage)
{
        switch(copy_u8ReferrenceVoltage)
		{
			case VOLTAGE_REFERENCE_AVREF:
			  CLR_BIT(ADMUX_REG ,ADMUX_REFS1);
			  CLR_BIT(ADMUX_REG ,ADMUX_REFS0);
			  break;
			case VOLTAGE_REFERENCE_INTERNAL:
			 SET_BIT(ADMUX_REG ,ADMUX_REFS1);
			 SET_BIT(ADMUX_REG ,ADMUX_REFS0);
			 break;
			case VOLTAGE_REFERENCE_AVCC:
			 CLR_BIT(ADMUX_REG ,ADMUX_REFS1);
			 SET_BIT(ADMUX_REG ,ADMUX_REFS0);
			 break;
			
		}
		
		
		#if ADJUSTMENT == LEFT_ADJUSTMENT
		SET_BIT(ADMUX_REG,ADMUX_ADLAR);
		#elif ADJUSTMENT == RIGHT_ADJUSTMENT
		CLR_BIT(ADMUX_REG,ADMUX_ADLAR);
		#endif


		#if ADC_PRESCALLER == DIVID_BY_2
		SET_BIT( ADCSRA_REG,ADCSRA_ADPS0);
		CLR_BIT( ADCSRA_REG,ADCSRA_ADPS1 );
		CLR_BIT( ADCSRA_REG,ADCSRA_ADPS2);
		
		#elif ADC_PRESCALLER == DIVID_BY_4
		CLR_BIT(ADCSRA_REG,ADCSRA_ADPS0 );
		SET_BIT( ADCSRA_REG,ADCSRA_ADPS1);
		CLR_BIT( ADCSRA_REG,ADCSRA_ADPS2);
		
		
		#elif ADC_PRESCALLER == DIVID_BY_8
		SET_BIT(ADCSRA_REG,ADCSRA_ADPS0 );
		SET_BIT( ADCSRA_REG,ADCSRA_ADPS1 );
		CLR_BIT( ADCSRA_REG,ADCSRA_ADPS2 );

		#elif ADC_PRESCALLER == DIVID_BY_16
		CLR_BIT(ADCSRA_REG,ADCSRA_ADPS0);
		CLR_BIT(ADCSRA_REG,ADCSRA_ADPS1);
		SET_BIT(ADCSRA_REG,ADCSRA_ADPS2);
		
		#elif ADC_PRESCALLER == DIVID_BY_32
		SET_BIT(ADCSRA_REG,ADCSRA_ADPS0);
		CLR_BIT(ADCSRA_REG,ADCSRA_ADPS1);
		SET_BIT(ADCSRA_REG,ADCSRA_ADPS2);

		#elif ADC_PRESCALLER == DIVID_BY_64
		CLR_BIT(ADCSRA_REG,ADCSRA_ADPS0);
		SET_BIT(ADCSRA_REG,ADCSRA_ADPS1);
		SET_BIT(ADCSRA_REG,ADCSRA_ADPS2);

		#elif ADC_PRESCALLER == DIVID_BY_128
		SET_BIT(ADCSRA_REG,ADCSRA_ADPS2);
		SET_BIT(ADCSRA_REG,ADCSRA_ADPS1);
		SET_BIT(ADCSRA_REG,ADCSRA_ADPS0);

		#endif

		#if ADC_AUTOTRIGGERED_MODE == SINGLE_CONVERSION
		CLR_BIT(ADCSRA_REG,ADCSRA_ADATE);
		#elif ADC_AUTOTRIGGERED_MODE == AUTOTRIGGERED
		SET_BIT(ADCSRA_REG,ADCSRA_ADATE);
		    #if ADC_AUTO_TRIGGER_SOURCE == FREE_RUNNING_MODE
		    CLR_BIT(SFIOR_REG,SFIOR_ADTS0);
		    CLR_BIT(SFIOR_REG,SFIOR_ADTS1);
		    CLR_BIT(SFIOR_REG,SFIOR_ADTS2);
		    #endif
		#endif

		#if INTTERUPT_MODE ==  INTERRUPT_ENABLE  
		SET_BIT(ADCSRA_REG,ADCSRA_ADIE);
		#elif INTTERUPT_MODE ==  INTERRUPT_DISABLE	
		CLR_BIT(ADCSRA_REG,ADCSRA_ADIE);
		#endif
		
		#if ADC_MODE==ADC_ENABLE
		SET_BIT(ADCSRA_REG,ADCSRA_ADEN);
		#elif ADC_MODE==ADC_DISABLE
		CLR_BIT(ADCSRA_REG,ADCSRA_ADEN);
		#endif	
}							   

void ADC_voidGetDigitalValue(u8 copy_u8ChannelNumber,u16* copy_pu16DigitalValue)
{
	if((copy_pu16DigitalValue!=NULL)&&(copy_u8ChannelNumber<32))
	{
		//clear channel bit 
		ADMUX_REG &=   0xE0;     //0b11100000;
		//SELECT CHANNEL 
		ADMUX_REG |= copy_u8ChannelNumber;
		
		//start conversion
		SET_BIT(ADCSRA_REG,ADCSRA_ADSC);

		while(!GET_BIT(ADCSRA_REG,ADCSRA_ADIF))
		{
			//POLLING : BUSY WAITING UNTIL EVENT
			//fix me: need time out
			
			
		}

		//CLEAR THE FLAG
		SET_BIT(ADCSRA_REG,ADCSRA_ADIF);
		
		*copy_pu16DigitalValue = ADC_REG;
		
	}
	else
	{
		//error state
	}
}